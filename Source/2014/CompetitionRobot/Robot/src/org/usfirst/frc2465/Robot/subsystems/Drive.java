// RobotBuilder Version: 1.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc2465.Robot.subsystems;

import com.kauailabs.nav6.frc.IMUAdvanced;
import org.usfirst.frc2465.Robot.RobotMap;
import edu.wpi.first.wpilibj.*;
import edu.wpi.first.wpilibj.can.*;
import edu.wpi.first.wpilibj.command.PIDSubsystem;
import org.usfirst.frc2465.Robot.RobotPreferences;


/**
 *
 */

public class Drive extends PIDSubsystem {
    
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    IMUAdvanced imu = RobotMap.imu;
    CANJaguar leftFrontSC = RobotMap.driveLeftFrontSC;
    CANJaguar leftRearSC = RobotMap.driveLeftRearSC;
    CANJaguar rightFrontSC = RobotMap.driveRightFrontSC;
    CANJaguar rightRearSC = RobotMap.driveRightRearSC;
    RobotDrive robotDrive = RobotMap.driveRobotDrive;
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    static final double cWidth          = 19.0;                 // Distance between left/right wheels
    static final double cLength         = 22.25;                // Distance btwn front/back wheels
    static final double wheelDiameter   = 6.0;                  // Per AndyMark Specs
    static final double wheelRadius     = wheelDiameter / 2;

    static final int VX    = 0;
    static final int VY    = 1;
    static final int VROT  = 2;

    public static final int ROTATE_DIRECTION  = -1;
    public static final int DRIVE_DIRECTION = -1;    
    
/////////////////////////////////////////////////////////////////////////////////////
// Mecanum Constants
/////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////
// Proportional translation vs. Rotation
//
// For the same motor speed, the distance of translation and distance of rotation
// are not the same, due to the proportions of the wheel radius, and the 
// distance between front/back and left/right wheels.
//////////////////////////////////////////////////////////

    static final double cRotK = ((cWidth + cLength)/2) / wheelRadius;               // Rotational Coefficient

    static double invMatrix[][] = new double[][] {
        {  -1, 1,  cRotK },
        {   1, 1, -cRotK },
        {   1, 1,  cRotK },
        {  -1, 1, -cRotK },        
    };
       
    static final int WHEEL_FRONTLEFT       = 2;
    static final int WHEEL_FRONTRIGHT      = 3;
    static final int WHEEL_REARLEFT        = 4;
    static final int WHEEL_REARRIGHT       = 5;    
    
    CANJaguar.ControlMode currControlMode;
    int maxOutputSpeed;
    int maxSpeedModeRPMs;    
    double tolerance_degrees;
    
    public Drive() {
        super(  "Drive",
                RobotPreferences.getAutoRotateP(),
                RobotPreferences.getAutoRotateI(),
                RobotPreferences.getAutoRotateD());

        getPIDController().setContinuous(false);
        getPIDController().setInputRange(0,360);
        getPIDController().setOutputRange(-1, 1);
        tolerance_degrees = RobotPreferences.getAutoRotateOnTargetToleranceDegrees();
        getPIDController().setAbsoluteTolerance(tolerance_degrees);
        setSetpoint(RobotPreferences.getAutoRotateDefaultTaretDegrees());
        disable();
        
        robotDrive.setSafetyEnabled(false);
    }
    
    // Put methods for controlling this subsystem
    // here. Call these from Commands.

    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
	
        // Set the default command for a subsystem here.
        //setDefaultCommand(new MySpecialCommand());
    }

    void initMotor( CANJaguar motor ) {
        try {
            motor.changeControlMode( currControlMode );
            if ( currControlMode == CANJaguar.ControlMode.kSpeed )
            {
                //motor.ConfigEncoderCodesPerRev(360);
                motor.configEncoderCodesPerRev(250);
                motor.configMaxOutputVoltage(12.0);
                motor.configNeutralMode(CANJaguar.NeutralMode.kBrake);
                motor.setPID(.7,.004,0);
                motor.setSpeedReference(CANJaguar.SpeedReference.kQuadEncoder);
            }
            motor.enableControl();
        } catch (CANTimeoutException ex) {
            ex.printStackTrace();
        }
    }    
    
    void setMode( CANJaguar.ControlMode controlMode ) {
        
        currControlMode = controlMode;

        if ( currControlMode == CANJaguar.ControlMode.kSpeed )
        {
                maxOutputSpeed = maxSpeedModeRPMs;
        }
        else // kPercentVbus
        {
                maxOutputSpeed = 1;
        }
        
        initMotor(leftFrontSC);
        initMotor(rightFrontSC);
        initMotor(leftRearSC);
        initMotor(leftFrontSC);    
    }    
    
    void checkForRestartedMotor( CANJaguar motor, String strDescription )
    {
        if ( currControlMode != CANJaguar.ControlMode.kSpeed )   // kSpeed is the default
        {
            try {
                if ( motor.getPowerCycled() )
                {
                    Timer.delay(0.10); // Wait 100 ms
                    initMotor( motor );
                    String error = "\n\n>>>>" + strDescription + "Jaguar Power Cycled - re-initializing";
                    System.out.println(error);
                    //setErrorData(error, strlen(error), 100);
                }
            } catch (CANTimeoutException ex) {
                ex.printStackTrace();
            }
        }
    }    

    void mecanumDriveFwdKinematics( double wheelSpeeds[], double velocities[] )
    {
        for ( int i = 0; i < 3; i++ )
        {
            velocities[i] = 0;
            for ( int wheel = 0; wheel < 4; wheel ++ )
            {
                    velocities[i] += wheelSpeeds[wheel] * (1 / invMatrix[wheel][i]);
            }
            velocities[i] *= ((double)1.0/4);
        }
    }

    void mecanumDriveInvKinematics( double velocities[], double[] wheelSpeeds)
    {
        for ( int wheel = 0; wheel < 4; wheel ++ )
        {
            wheelSpeeds[wheel] = 0;
            for ( int i = 0; i < 3; i++ )
            {
                    wheelSpeeds[wheel] += velocities[i] * invMatrix[wheel][i];
            }
        }
    }    

    boolean fod_enable = false;
    double next_autorotate_value = 0.0;
    
    public void doMecanum( double vX, double vY, double vRot) {
        
        // If auto-rotating, replace vRot with the next
        // calculated value
        
        if ( getAutoRotation() ) {
            vRot = next_autorotate_value;
        }
        
        boolean imu_connected = imu.isConnected();
                
        // Field-oriented drive - Adjust input angle for gyro offset angle
        
        double curr_gyro_angle_degrees = 0;
        if ( fod_enable && imu_connected ) 
        {
                curr_gyro_angle_degrees = imu.getYaw();
        }
        double curr_gyro_angle_radians = curr_gyro_angle_degrees * Math.PI/180;       
        
        double temp = vY * Math.cos( curr_gyro_angle_radians ) + vX * Math.sin( curr_gyro_angle_radians);
        vX = -vY * Math.sin( curr_gyro_angle_radians ) + vX * Math.cos( curr_gyro_angle_radians );
        vY = temp;     
        
        try {
            double excessRatio = (double)1.0 / ( Math.abs(vX) + Math.abs(vY) + Math.abs(vRot) );
            if ( excessRatio < 1.0 )
            {
                vX              *= excessRatio;
                vY              *= excessRatio;
                vRot    *= excessRatio;
            }
            
            vRot *= (1/cRotK);
            
            double wheelSpeeds[] = new double[4];
            double velocities[] = new double[3];
            velocities[0] = vX;
            velocities[1] = vY;
            velocities[2] = vRot;
            
            mecanumDriveInvKinematics( velocities, wheelSpeeds );
            
            byte syncGroup = (byte)0x80;
            
            checkForRestartedMotor( leftFrontSC, "Front Left" );
            checkForRestartedMotor( rightFrontSC, "Front Right" );
            checkForRestartedMotor( leftRearSC, "Rear Left" );
            checkForRestartedMotor( rightRearSC, "Rear Right" );
            
            leftFrontSC.setX(maxOutputSpeed * wheelSpeeds[0] * -1 * DRIVE_DIRECTION, syncGroup );
            rightFrontSC.setX(maxOutputSpeed * wheelSpeeds[1] * DRIVE_DIRECTION, syncGroup);
            leftRearSC.setX(maxOutputSpeed * wheelSpeeds[2] * -1 * DRIVE_DIRECTION, syncGroup);
            rightRearSC.setX(maxOutputSpeed * wheelSpeeds[3] * DRIVE_DIRECTION, syncGroup);
            
            CANJaguar.updateSyncGroup(syncGroup);
        } catch (CANTimeoutException ex) {
            ex.printStackTrace();
        }        
    }

    protected double returnPIDInput() {
        double current_yaw = 0.0;
        if ( imu.isConnected() ) {
            current_yaw = imu.getYaw();
        }
        return current_yaw;
    }

    protected void usePIDOutput(double d) {
        next_autorotate_value = d;
    }
    
    public void setAutoRotation(boolean enable) {
        if ( enable ) {
            getPIDController().enable();
            next_autorotate_value = 0.0;
        }
        else {
            getPIDController().disable();
        }
    }
    
    public boolean getAutoRotation() {
        return getPIDController().isEnable();
    }
    
    public void setFODEnabled(boolean enabled) {
        fod_enable = enabled;
    }
    
    public boolean getFODEnabled() {
        return fod_enable;
    }
}

