// RobotBuilder Version: 1.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc2465.Robot.subsystems;

import org.usfirst.frc2465.Robot.RobotMap;
import org.usfirst.frc2465.Robot.commands.*;
import edu.wpi.first.wpilibj.*;
import edu.wpi.first.wpilibj.command.PIDSubsystem;

import edu.wpi.first.wpilibj.command.Subsystem;
import org.usfirst.frc2465.Robot.RobotPreferences;


/**
 *
 */
public class Arms extends PIDSubsystem {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    public SpeedController sC = RobotMap.armsSC;
    DigitalInput min = RobotMap.armsMin;
    DigitalInput max = RobotMap.armsMax;
    AnalogChannel sensor = RobotMap.armsSensor;
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    
    public static final int kStateLow           = 0; 
    public static final int kStateMid           = 1; 
    public static final int kStateHigh          = 2;
    public static final int kStateUp            = 3;
    public static final int kStateIndeterminate = 4;    
    
    public double tolerance_degrees;
    public double low_degrees;
    public double mid_degrees;
    public double high_degrees;
    public double up_degrees;
    
    public Arms() {
        
        super(  "Arms",
                RobotPreferences.getArmsP(),
                RobotPreferences.getArmsI(),
                RobotPreferences.getArmsD());
        
        max_theta   = RobotPreferences.getArmsMaxAngle();
        min_theta   = RobotPreferences.getArmsMinAngle();
        max_volt    = RobotPreferences.getArmsMaxSensorVolts();
        min_volt    = RobotPreferences.getArmsMinSensorVolts();
        
        ratio = (max_theta - min_theta) / (max_volt - min_volt);
        
        // Configure the PID Controller
        
        getPIDController().setContinuous(false);
        getPIDController().setInputRange(min_theta, max_theta);
        getPIDController().setOutputRange(-1, 1);
        tolerance_degrees = RobotPreferences.getAnkleOnTargetToleranceDegrees();
        getPIDController().setAbsoluteTolerance(tolerance_degrees);
        setSetpoint(RobotPreferences.getAnkleDefaultAngle());
        
        low_degrees     = RobotPreferences.getArmsAngleLow();
        mid_degrees     = RobotPreferences.getArmsAngleMid();
        high_degrees    = RobotPreferences.getArmsAngleHigh();
        up_degrees      = RobotPreferences.getArmsAngleUp();
        
        // Start the PID Controller
        
        enable();
    }
    
    // Put methods for controlling this subsystem
    // here. Call these from Commands.

    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
	
        // Set the default command for a subsystem here.
        //setDefaultCommand(new MySpecialCommand());
    }
    
    public double getAngle() {
        return
            ratio * (sensor.getAverageVoltage() - min_volt) + min_theta;
                
    }

    public boolean isAtMin() {
        return min.get();
    }
    
    public boolean isAtMax() {
        return max.get();
    }
    
    public void stop() {
        disable();
    }
    
    public void goToAngle( double angle ) {
        setSetpoint(angle);
        enable();
    }
    
    double ratio;
    double max_theta;
    double min_theta;
    double max_volt;
    double min_volt;

    protected double returnPIDInput() {
        return getAngle();
    }

    protected void usePIDOutput(double d) {
        
        if ( min.get() || max.get() ) {
            d = 0;
        }
        
        this.sC.set(d);
    }

    public int getState() {
        double set_point = getPIDController().getSetpoint();
        boolean on_target = getPIDController().onTarget();
        int state;
        if ( !on_target ) {
            state = kStateIndeterminate;
        }
        else {
            if ( ( set_point > (low_degrees - tolerance_degrees ) ) &&
                 ( set_point < (low_degrees + tolerance_degrees ) ) ) {
                state = kStateLow;
            }
            else if ( ( set_point > (mid_degrees - tolerance_degrees ) ) &&
                 ( set_point < (mid_degrees + tolerance_degrees ) ) ) {
                state = kStateMid;
            }
            else if ( ( set_point > (high_degrees - tolerance_degrees ) ) &&
                 ( set_point < (high_degrees + tolerance_degrees ) ) ) {
                state = kStateHigh;
            }
            else if ( ( set_point > (up_degrees - tolerance_degrees ) ) &&
                 ( set_point < (up_degrees + tolerance_degrees ) ) ) {
                state = kStateUp;
            }
            else {
                state = kStateIndeterminate;
            }
        }
        return state;
    }
    
}

